# Регистры общего назначения  

Регистры общего назначения (General Purpose Registers, GPR) — это регистры внутри процессора, предназначенные для хранения промежуточных данных при выполнении операций, а также для использования в качестве адресных регистров. В зависимости от архитектуры процессора их количество и функциональность могут отличаться.  

На примере **архитектуры x86** разберем основные регистры общего назначения:  

---

#### 1. **AX, BX, CX, DX** (16-разрядные регистры)  
Эти регистры имеют исторически сложившиеся специальные функции, но в современных процессорах используются как универсальные:  

- **AX (Accumulator Register)**  
  - Часто используется для арифметических и логических операций.  
  - Некоторые команды по умолчанию работают с AX.  
  ```asm
  MOV AX, 1234h  ; Загрузить значение 1234h в AX
  ADD AX, BX     ; Сложить AX и BX
  ```  

- **BX (Base Register)**  
  - Может использоваться для адресации памяти.  
  ```asm
  MOV BX, 1000h  ; Загрузить базовый адрес
  MOV AX, [BX]   ; Прочитать данные по адресу BX
  ```  

- **CX (Count Register)**  
  - Применяется как счетчик в циклах и при повторении команд (например, `LOOP` или `REP`).  
  ```asm
  MOV CX, 10     ; Установить счетчик в 10
  LOOP label     ; Повторять до CX = 0
  ```  

- **DX (Data Register)**  
  - Используется для хранения данных, особенно в операциях ввода-вывода и деления/умножения.  
  ```asm
  MOV AX, 1000h
  MOV DX, 10
  DIV DX         ; AX = AX / DX, остаток в DX
  ```  

---

#### 2. **8-разрядные подрегионы (AL, AH, BL, BH, CL, CH, DL, DH)**  
Каждый 16-разрядный регистр разделяется на два 8-разрядных:  

- **AL, AH** — младшая (Low) и старшая (High) части регистра AX.  
- **BL, BH** — младшая и старшая части BX.  
- **CL, CH** — младшая и старшая части CX.  
- **DL, DH** — младшая и старшая части DX.  

Пример:  
```asm
MOV AL, 0FFh    ; Загрузить 255 в младшую часть AX
MOV AH, 01h     ; Загрузить 1 в старшую часть AX
; Теперь AX = 0x01FF
```  

---

#### 3. **32-разрядные и 64-разрядные расширения** (в современных процессорах)  

- В процессорах x86 (32-разрядных) регистры расширяются до **EAX, EBX, ECX, EDX**.  
  ```asm
  MOV EAX, 12345678h ; Загрузить 32-разрядное значение в EAX
  ```  

- В 64-разрядных процессорах (x86-64) регистры расширяются до **RAX, RBX, RCX, RDX**.  
  ```asm
  MOV RAX, 1234567890ABCDEFh ; Загрузить 64-разрядное значение
  ```  

- Кроме того, были добавлены 8 новых 64-битных регистров R8 - R15
---


### Использование регистров в адресации  

Регистры общего назначения также применяются для адресации памяти:  

- Прямая адресация:  
  ```asm
  MOV AX, [1000h]  ; Прочитать значение по адресу 1000h
  ```  

- Косвенная адресация через регистр:  
  ```asm
  MOV BX, 1000h
  MOV AX, [BX]     ; Прочитать значение по адресу, содержащемуся в BX
  ```  

- Индексная адресация:  
  ```asm
  MOV SI, 200h
  MOV AX, [SI + 10h] ; Прочитать значение с учетом смещения
  ```  

---

Регистры общего назначения являются основным инструментом для выполнения вычислений и работы с памятью, что делает их незаменимыми при программировании на языке ассемблера.

### Сводная таблица регистров общего назначения

| Регистр | Название               | Описание                                                                 |
|---------|------------------------|--------------------------------------------------------------------------|
| AX      | Accumulator            | Используется для арифметических операций                                 |
| BX      | Base                   | Используется в качестве указателя на данные                              |
| CX      | Counter                | Используется для хранения счетчика цикла                                 |
| DX      | Data                   | Используется для арифметических операций и операций ввода-вывода         |

---


# Регистры-указатели  

Регистры-указатели (Pointer Registers) в архитектуре x86 предназначены для хранения адресов, которые используются для работы с памятью и управления выполнением программ. Эти регистры играют важную роль в процессах адресации, управления стэком и выполнении команд.

---

### 1. **SP (Stack Pointer)** — указатель стека  
Этот регистр содержит адрес вершины стека в памяти.  

- Используется при работе с командами `PUSH` и `POP`, которые добавляют или удаляют данные из стека.  
- Взаимодействует с регистром BP (Base Pointer) для доступа к данным внутри стека.  

Пример:  
```asm
PUSH AX          ; Сохранить значение AX в стеке
POP BX           ; Извлечь верхнее значение из стека в BX
```

---

### 2. **BP (Base Pointer)** — базовый указатель  
Этот регистр используется для доступа к данным, хранящимся в стеке, чаще всего внутри подпрограмм.  

- При вызове подпрограммы регистр BP обычно указывает на начало фрейма стека (контекст вызова).  
- Часто применяется вместе с относительной адресацией для доступа к параметрам и локальным переменным.  

Пример:  
```asm
MOV AX, [BP + 4]  ; Прочитать значение параметра из стека
MOV [BP - 2], AX  ; Записать значение в локальную переменную
```

---

### 3. **SI (Source Index)** — индекс источника  
Этот регистр применяется для работы с данными в памяти, особенно при выполнении операций над строками.  

- Используется как указатель на исходные данные (например, при копировании или сравнении строк).  
- Взаимодействует с командами `MOVS`, `CMPS` и другими.  

Пример:  
```asm
MOV SI, 1000h     ; Установить адрес исходных данных
MOV AX, [SI]      ; Прочитать данные из памяти по адресу SI
```

---

### 4. **DI (Destination Index)** — индекс назначения  
Этот регистр используется для указания адреса назначения при операциях над строками.  

- Применяется для указания, куда следует записать данные.  
- Работает с командами `MOVS`, `STOS`, `LODS` и другими.  

Пример:  
```asm
MOV DI, 2000h     ; Установить адрес назначения
MOV [DI], AX      ; Записать данные из AX по адресу DI
```

---

### 5. **Регистры SI и DI в операциях над строками**  

Регистры SI и DI часто используются вместе для обработки строк с командами повторения (`REP`).  

Пример: копирование строки:  
```asm
MOV CX, 10        ; Установить длину строки
MOV SI, 1000h     ; Адрес исходных данных
MOV DI, 2000h     ; Адрес назначения
REP MOVSB         ; Копировать CX байтов из SI в DI
```

---

### 6. **IP (Instruction Pointer)** — указатель инструкции  
Этот регистр хранит адрес следующей команды, которая должна быть выполнена.  

- Автоматически изменяется процессором после выполнения команды.  
- Используется при переходах, вызовах и возвратах из подпрограмм.  

Пример:  
```asm
JMP LABEL         ; Изменить значение IP для перехода к метке LABEL
CALL FUNCTION     ; Сохранить текущий IP и перейти к FUNCTION
RET               ; Вернуться к адресу, сохраненному в стеке
```

---
### 7. **Особенности указателей в 32- и 64-разрядных архитектурах**  

В 32-разрядной архитектуре (x86):  
- Регистры расширены до **ESP (Extended Stack Pointer)**, **EBP (Extended Base Pointer)**, **ESI (Extended Source Index)**, **EDI (Extended Destination Index)**.  

В 64-разрядной архитектуре (x86-64):  
- Регистры расширены до **RSP**, **RBP**, **RSI**, **RDI**.  
- Используются для работы с 64-разрядными адресами.  

Пример в x86-64:  
```asm
MOV RSP, 7FFFE000h ; Установить адрес вершины стека
MOV RSI, 12345678h ; Установить адрес исходных данных
MOV RDI, 87654321h ; Установить адрес назначения
```

---




### Сводная таблица регистров-указателей

| Регистр | Название               | Описание                                                                 |
|---------|------------------------|--------------------------------------------------------------------------|
| SP      | Stack Pointer          | Указывает на вершину стека                                              |
| BP      | Base Pointer           | Указывает на базу фрейма текущего стека                                 |
| SI      | Source Index           | Указывает на адрес исходных данных                                      |
| DI      | Destination Index      | Указывает на адрес назначения данных                                    |
| IP      | Instruction Pointer    | Указывает на следующую команду для выполнения                           |

---

### Пример программы с регистрами-указателями  

Программа вычисляет сумму двух чисел, хранящихся в стеке:  
```asm
section .data

section .text
    MOV AX, 5          ; Первое число
    PUSH AX            ; Сохранить в стеке
    MOV AX, 10         ; Второе число
    PUSH AX            ; Сохранить в стеке

    MOV BP, SP         ; Установить базовый указатель на вершину стека
    MOV AX, [BP]       ; Прочитать первое число
    ADD AX, [BP + 2]   ; Сложить со вторым числом
    MOV SP, BP         ; Восстановить указатель стека
    POP BX             ; Очистить стек
    POP BX             ; Очистить стек

    HLT                ; Завершение программы
```  

Регистры-указатели обеспечивают гибкость и мощные инструменты для управления памятью и выполнения команд, что делает их ключевыми элементами работы процессора.

## Регистр флагов

Регистр флагов RFLAGS, содержит биты состояния процессора:

| Бит | Имя |Назначение |
|-----|-----|-----------|
|0|**CF**| Флаг переноса (Carry flag): показывает, был ли при сложении перенос или заимствование при вычитании. Используется в качестве входных данных для инструкций сложения и вычитания.|
|2|PF|Флаг четности: устанавливается, если младшие 8 битов результата содержат четное число единиц.|
|4|AF|Флаг настройки: указывает, был ли при сложении перенос или заимствование при вычитании младших 4 битов.|
|6|**ZF**|Флаг нуля (Zero flag): устанавливается, если результат операции равен нулю|
|7|**SF**|Флаг знака (Sign flag): устанавливается, если результат операции отрицательный.|
|8|TF|Флаг прерывания выполнения (Trap flag): используется при одношаговой отладке.|
|9|IF|Флаг разрешения прерывания: установка этого бита разрешает аппаратные прерывания.|
|10|DF|Флаг направления: контролирует направление обработки. Если не установлен, то порядок от самого младшего до самого старшего адреса. Если установлен, то порядок обратный - от самого старшего до самого младшего адреса.|
|11|**OF**|Флаг переполнения (Overflow flag): если устанавлен, то операция привела к переполнению со знаком.|
|12-13|IOPL|Уровень привилегий ввода-вывода (I/O privilege level): уровень привилегий текущего выполняемого потока. IOPL 0 — это режим ядра, а 3 — пользовательский режим.|
|14|NT|Флаг вложенной задачи (Nested task flag): управляет цепочкой прерываний.|
|16|RF|Флаг возобновления (Resume flag): используется для обработки исключений во время отладки.|
|17|VM|Флаг режима виртуальной машины 8086: если установлен, режим совместимости с 8086 активен. Этот режим позволяет запускать некоторые приложения MS-DOS в контексте операционной системы в защищенном режиме.|
|18|AC|Флаг проверки выравнивания (Alignment check flag): если установлен, проверка выравнивания памяти активна. Например, если установлен флаг AC, сохранение 16-битного значения по нечетному адресу вызывает исключение проверки выравнивания. Процессоры x86 могут выполнять невыровненный доступ к памяти, когда этот флаг не установлен, но количество требуемых командных циклов может увеличиться.|
|19|VIF|Флаг виртуального прерывания (Virtual interrupt flag): виртуальная версия флага IF в виртуальном режиме 8086..|
|20|VIP|Флаг ожидания виртуального прерывания: Устанавливается, когда прерывание находится в состоянии ожидания в виртуальном режиме 8086.|
|21|ID|Флаг ID: если этот бит установлен, то поддерживается инструкция cpuid. Эта инструкция возвращает идентификатор процессора и информацию о его функциях.|

Основными являются флаги переноса, нуля, знака и переполнения, которые называют флагами состояния. Как видно, не все биты из 64-х разрядного регистра флагов имеют назначение. Неуказанные биты не используются.

Флаг считается установленным, если он имеет значение 1.

## Сегментные регистры

В программной модели микропроцессора имеется шесть сегментных регистров: `CS`, `SS`, `DS`, `ES`, `GS`, `FS`.
Их существование обусловлено спецификой организации и использования оперативной памяти микропроцессорами Intel. Она заключается в том, что микропроцессор аппаратно поддерживает структурную организацию программы в виде трех частей, называемых сегментами. Соответственно, такая организация памяти называется сегментной.

Микропроцессор поддерживает следующие типы сегментов:
- **Сегмент кода.** Содержит команды программы.
Для доступа к этому сегменту служит регистр `CS` (code segment register) — сегментный регистр кода. Он содержит адрес сегмента с машинными командами, к которому имеет доступ микропроцессор (то есть эти команды загружаются в конвейер микропроцессора).
- **Сегмент данных.** Содержит обрабатываемые программой данные.
Для доступа к этому сегменту служит регистр `DS` (data segment register) — сегментный регистр данных, который хранит адрес сегмента данных текущей программы.
- **Сегмент стека.** Этот сегмент представляет собой область памяти, называемую стеком.
Работу со стеком микропроцессор организует по следующему принципу: последний записанный в эту область элемент выбирается первым. Для доступа к этому сегменту служит регистр `SS` (stack segment register) — сегментный регистр стека, содержащий адрес сегмента стека.
- **Дополнительный сегмент данных.**
Неявно алгоритмы выполнения большинства машинных команд предполагают, что обрабатываемые ими данные расположены в сегменте данных, адрес которого находится в сегментном регистре `DS`.
Если программе недостаточно одного сегмента данных, то она имеет возможность использовать еще три дополнительных сегмента данных. Но в отличие от основного сегмента данных, адрес которого содержится в сегментном регистре `DS`, при использовании дополнительных сегментов данных их адреса требуется указывать явно с помощью специальных префиксов переопределения сегментов в команде.
Адреса дополнительных сегментов данных должны содержаться в регистрах `ES`, `GS`, `FS` (extension data segment registers).

## Общая таблица регистров

<table width="1000" border="1" style="text-align:center; font-family: Courier New; font-size: 8pt">
<tbody>
    <tr>
        <td colspan="8" width="10%">63-0</td>
        <td colspan="8" width="10%">RAX</td>
        <td colspan="8" width="10%">RCX</td>
        <td colspan="8" width="10%">RDX</td>
        <td colspan="8" width="10%">RBX</td>
    </tr>
    <tr>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">31-0</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">EAX</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">ECX</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">EDX</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">EBX</td>
    </tr>
    <tr>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">15-0</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">AX</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%" >CX</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%" >DX</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%" >BX</td>
    </tr>
    <tr>
        <td colspan="6" width="7.5%"></td>
        <td width="1.25%">15-8</td>
        <td width="1.25%">7-0</td>
        <td colspan="6" width="7.5%"></td>
        <td width="1.25%">AH</td>
        <td width="1.25%">AL</td>
        <td colspan="6" width="7.5%"></td>
        <td width="1.25%">CH</td>
        <td width="1.25%">CL</td>
        <td colspan="6" width="7.5%"></td>
        <td width="1.25%">DH</td>
        <td width="1.25%">DL</td>
        <td colspan="6" width="7.5%"></td>
        <td width="1.25%" >BH</td>
        <td width="1.25%" >BL</td>
    </tr>
</tbody>
</table>

<table width="1000" border="1" style="text-align:center; font-family: Courier New; font-size: 8pt">
<tbody>
    <tr>
        <td colspan="8" width="10%">RSP</td>
        <td colspan="8" width="10%">RBP</td>
        <td colspan="8" width="10%">RSI</td>
        <td colspan="8" width="10%">RDI</td>
        <td colspan="8" width="10%">Rx</td>
    </tr>
    <tr>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">ESP</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">EBP</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">ESI</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">EDI</td>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">RxD</td>
    </tr>
    <tr>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">SP</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">BP</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">SI</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">DI</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">RxW</td>
    </tr>
    <tr>
        <td colspan="7" width="8.75%"></td>
        <td width="1.25%">SPL</td>
        <td colspan="7" width="8.75%"></td>
        <td width="1.25%">BPL</td>
        <td colspan="7" width="8.75%"></td>
        <td width="1.25%">SIL</td>
        <td colspan="7" width="8.75%"></td>
        <td width="1.25%">DIL</td>
        <td colspan="7" width="8.75%"></td>
        <td width="1.25%">RxB</td>
    </tr>
</tbody>
</table>

<table width="1000" border="1" style="text-align:center; font-family: Courier New; font-size: 8pt">
<tbody>
    <tr>
        <td colspan="8" width="10%">RFLAGS</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">CS</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">GS</td>
        <td colspan="8" width="10%"></td>
        <td colspan="8" width="10%"></td>
    </tr>
    <tr>
        <td colspan="4" width="5%"></td>
        <td colspan="4" width="5%">EFLAGS</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">DS</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">SS</td>
        <td colspan="8" width="10%"></td>
        <td colspan="8" width="10%"></td>
    </tr>
    <tr>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">FLAGS</td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">ES</td>
        <td colspan="8" width="10%"></td>
        <td colspan="8" width="10%"></td>
        <td colspan="8" width="10%"></td>
    </tr>
    <tr>
        <td colspan="7" width="8.75%"></td>
        <td width="1.25%"></td>
        <td colspan="6" width="7.5%"></td>
        <td colspan="2" width="2.5%">FS</td>
        <td colspan="8" width="10%"></td>
        <td colspan="8" width="10%"></td>
        <td colspan="8" width="10%"></td>
    </tr>
</tbody>
</table>
