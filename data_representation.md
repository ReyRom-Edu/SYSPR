# Представление данных в компьютере

## Целые числа

Компьютер хранит и обрабатывает всю информацию в виде битов (двоичных цифр: `0` и `1`). Это связано с тем, что электронные компоненты компьютера (транзисторы, конденсаторы) могут надежно различать два состояния:

* `0` — отсутствие сигнала (низкое напряжение, `false`)
* `1` — наличие сигнала (высокое напряжение, `true`)

Два бита вместе могут принимать четыре значения: 00, 01, 10 и 11. Три бита могут принимать восемь значений: 000, 001, 010, 011, 100, 101, 110 и 111. Обобщая, группа из n битов может принимать $2^n$ значений. Таким образом, группа из 8 бит или 1 байт может представлять $2^8$, то есть 256 уникальных значений. Таким образом, вся информация в компьютере фактически представляет последовательность бит.

Если число большое, то запись двоичных чисел может быть довольно длинной и поэтому не очень удобной. Например, число $234_{10}$ в двоичной системе равно $11101010_2$. И для упрощения работы с двоичными числами применяется шестнадцатеричная система.

При работе с разными системами счисления легко запутаться. Например, какую систему в реальности представляет число 1010? Оно может равным образом представлять и десятичную, и двоичную, и шестнадцатеричную. И чтобы указать, что число относится к определенной системе счисления, используют различные обозначения. 

Так, для указания, что число является двоичным, перед число обычно ставится префикс 0b:

`0b1010` - двоичное число (в десятичной системе равно 10, а в шестнадцатеричной - A)

Чтобы указать, что число является шестнадцатеричным, перед числом обычно ставится префикс 0x:

`0x1010` - шестнадцатеричное число (в десятичной системе равно 4112, а в двоичной - 1000000010000)

## Отрицательные целые числа

Для представления отрицательных чисел обычно используется **дополнение до двух (_two’s complement_)**, потому что:
* Позволяет выполнять арифметические операции (сложение, вычитание) без дополнительных проверок знака.
* Устраняет проблему "двойного нуля" (как в прямом коде или дополнении до 1).
* Один диапазон чисел для знаковых и беззнаковых операций.

С точки зрения математики чтобы получить отрицательный аналог числа надо от 0 (нуля) вычесть это число. Например, для получения -1 надо произвести операцию `0 - 1 = -1`. С точки зрения архитектуры компьютера в качестве 0 выступает число $2^n$. В данном случае степень $n$ представляет количество битов в числе.

Алгоритм получения отрицательного числа:
1. Инвертировать все биты (заменить 0 на 1 и наоборот) → получаем дополнение до 1 (one’s complement).
2. Добавить 1 к результату → получаем дополнение до 2 (two’s complement).

### Например:

Число 5 в двоичном виде: `0000 0101`

**Шаг 1**: Инвертируем биты (one’s complement): `~ 0000 0101 = 1111 1010`

**Шаг 2**: Добавляем 1 (two’s complement): `1111 1010 + 1 = 1111 1011`

**Итог**: `1111 1011 = -5` в two’s complement.

Сумма числа и его дополнения до 2 равна $2^n$: `5 + (-5) = 0000 0101 + 1111 1011 = 1 0000 0000` (перенос за пределы 8 бит игнорируется → 0)

**Пример: $7 - 5$**: `7 + (-5) = 0000 0111 + 1111 1011 = 1 0000 0010 → 0000 0010 = 2`

Диапазон чисел в two’s complement:

* Для n бит: от $-2^{n-1}$ до $2^{n-1}-1$
* 8 бит (`int8_t`): от $-128$ до $127$
* 16 бит (`int16_t`): от $-32768$ до $32767$


## Вещественные числа

Вещественные (дробные) числа в компьютере хранятся в формате **плавающей запятой** (floating-point), который позволяет представлять как очень малые, так и очень большие числа. Основной стандарт — IEEE 754, который определяет два основных формата:

* 32-битный (`float`, одинарная точность) $±3.4 × 10^{38}$

* 64-битный (`double`, двойная точность) $±1.8 × 10^{308}$

При этом такие числа все равно дают некотрую погрешность, например `0.1 + 0.2 ≠ 0.3` (в двоичной системе `0.1` — бесконечная дробь).  

### Структура числа в формате IEEE 754 (float, 32 бита / double, 64 бита)  
Число представляется в виде:  

$(-1)^S \times M \times 2^{E - \text{bias}}$

где:  
- **S (Sign, 1 бит)** — знак числа (`0` = положительное, `1` = отрицательное).  
- **E (Exponent, 8 бит / 11 бит)** — порядок (экспонента), хранится со смещением (bias = 127 / bias = 1023).  
- **M (Mantissa, 23 бита / 52 бита)** — мантисса (значащие биты дробной части, подразумевается скрытая единица).  

| S (1 бит) | E (8 бит)       | M (23 бита)            |
|-----------|-----------------|------------------------|
| 0 - 1   | 00000000 - 11111111 | 00000000000000000000000 - 1111111111111111111111 |


### Нормализация числа 
Любое число (кроме нуля) можно представить в **нормализованной форме**:  

$1.\text{MMMM} \times 2^{E - \text{bias}}$

- **Скрытая единица:** В нормализованных числах старший бит мантиссы всегда `1`, поэтому он не хранится явно (это экономит 1 бит).  

### Пример: представление числа `-13.625`  

**Шаг 1: Определение знака (S)**  
Число отрицательное → `S = 1`.  

**Шаг 2: Перевод целой и дробной части в двоичный вид**  
- **Целая часть (`13`):**  
  $13_{10} = 1101_2$
- **Дробная часть (`0.625`):**  
  ```math
  0.625 \times 2 = 1.25 \quad (\text{записываем } 1) \\
  0.25 \times 2 = 0.5 \quad (\text{записываем } 0) \\
  0.5 \times 2 = 1.0 \quad (\text{записываем } 1) \\
  0.625_{10} = 0.101_2
  ```
- **Объединение:**  
  $13.625_{10} = 1101.101_2$

**Шаг 3: Нормализация**  
- Сдвигаем точку, чтобы получилась форма $1.\text{MMMM} \times 2^E$:  
$1101.101_2 = 1.101101_2 \times 2^3$
- **Мантисса (`M`):** `101101` (дополняем нулями до 23 бит → `10110100000000000000000`).  
- **Экспонента (`E`):**  
  $E = 3 + \text{bias} = 3 + 127 = 130_{10} = 10000010_2$

**Шаг 4: Собираем битовое представление**  

|S  | Exponent (E) | Mantissa (M)           |
|---|--------------|------------------------|
|1  | 10000010     | 10110100000000000000000|

**Итоговое 32-битное число:**  
$1 \ 10000010 \ 10110100000000000000000$  (или в шестнадцатеричном виде: `0xC15A0000`) 

### Особые случаи в IEEE 754  
| Тип числа          | Экспонента (E)       | Мантисса (M)         | Пример (32 бита)       |
|--------------------|----------------------|----------------------|------------------------|
| **Нормализованное** | `1 ≤ E ≤ 254`        | Любая                | `1.101 × 2^3`          |
| **Ноль**           | `E = 0`              | `M = 0`              | `±0.0`                 |
| **Бесконечность**  | `E = 255`            | `M = 0`              | `±∞` (1/0, -1/0)       |
| **NaN (Not a Number)** | `E = 255`      | `M ≠ 0`              | `0/0`, `√(-1)`         |

  
