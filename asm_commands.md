# Команды языка ассемблера

Команды языка ассемблера прямо соответствуют отдельным командам процессора или их последовательностям и представляют собой более удобную для человека символьную форму записи команд и их аргументов

```asm
[метка]: [[префикс] мнемокод [операнд1 {, операнд2}]][;комментарий]
```

Мнемокод - инструкция процессору. К ней могут быть добавлены префиксы (повторения, изменения типа адресации и пр.) 

Операнды - объекты, на которые воздействует команда (константы, регистры, адреса в памяти и т.д.)

Команды языка ассемблера можно разделить на несколько категорий:  

---

### 1. **Команды перемещения данных**  
Перемещение данных между регистрами, памятью и непосредственными значениями.  

- **MOV** — перемещение данных:  
  ```asm
  MOV AX, BX        ; Скопировать значение из BX в AX
  MOV AX, 1234h     ; Загрузить в AX число 1234h
  MOV [SI], AX      ; Записать значение из AX по адресу, хранящемуся в SI
  MOV AL, [1234h]   ; Считать байт по адресу 1234h в AL
  ```  
  Оба операнда должны быть одинакового размера.

  Если необходимо поместить в регистр большего размера значение меньшего размера можно использовать команды перемещения с расширением: `MOVSX` для знакового расширения и `MOVZX` для беззнакового  
  ```
  MOVSXD dest, source     ; если dest - 64-разрядный операнд и source - 32-разрядный
  MOVSX dest, source      ; для всех остальных комбинаций операндов
  MOVZXD dest, source     ; если dest - 64-разрядный операнд и source - 32-разрядный
  MOVZX dest, source      ; для всех остальных комбинаций операндов
  ```
  Пример:
  ```asm
  MOV DL, -5
  MOVSX EAX, DL     ; EAX = -5
  ```

- **PUSH** — запись данных в стек:  
  ```asm
  PUSH AX           ; Сохранить значение AX в стеке
  ```  

- **POP** — извлечение данных из стека:  
  ```asm
  POP BX            ; Извлечь верхнее значение из стека в BX
  ```  

- **XCHG** — обмен значениями:  
  ```asm
  XCHG AX, BX       ; Поменять местами значения AX и BX
  ```  
---
### 2. **Команды сдвига и вращения**
Инструкции сдвига и вращения манипулируют отдельными битами числа.

- **SHL** — сдвиг влево 
    ```asm
    MOV AL, 5       ; в AL число 5 или 00000101
    SHL AL, 1       ; сдвигаем число в AL на 1 разряд влево = 00000101 << 1 = 00001010 = 10
    ```
    Фактически сдвиг влево на n разрядов эквивалентен умножению на 2^n
    ```asm
    MOV AL, 69      ; в AL число 69 или 01000101
    MOV CL, 2       ; в CL число 2
    SHL AL, CL      ; сдвигаем число в AL на 2 разряда влево = 01000101 << 2 = 00010100 = 20
    ```
    Стоит учитывать, что при сдвиге влево последний отбрасываемый бит копируется в регистр флагов во флаг переноса CF. Кроме флага CF инструкция сдвига также устанавливает и другие флаги состояния. Флаг нуля ZF устанавливается, если в результате сдвига получилось число 0. Флаг знака устанавливается, если старший бит результата равен 1. Флаг переполнения OF устанавливается, если при сдвиге на 1 разряд меняется старший бит (с 0 на 1 или с 1 на 0).

- **SHR** — логический сдвиг вправо 
    ```asm
    MOV AL, 69     ; в AL число 69 или 01000101
    SHR AL, 2      ; сдвигаем число в AL на 2 разряда вправо = 01000101 >> 2 = 00010001 = 17
    ```
    Фактически сдвиг вправо на n разрядов для беззнаковых чисел эквивалентен делению на 2^n

    При сдвиге вправо также устанавливаются флаги состояния. Последний отрасываемый бит копируется во флаг переноса CF. Если результат сдвига равен 0, то также устанавливается флаг нуля ZF. Если при сдвиге вправо на 1 разряд меняется старший бит (с 1 на 0), то также устанавливается флаг переполнения OF. При этом флаг знака SF всегда сбрасывается, так как слева в любом случае добавляется 0.

- **SAR** — арифметический сдвиг вправо. 
    
    По большей части работает аналогично логическому, за исключением того, что сдвигаемое число дополняется не 0, а значением старшего бита. Это может быть необходимо для работы с отрицательными числами.
    ```asm
    MOV EAX, -32    ; в EAX число -32 или FFFFFFE0h
    SHR EAX, 4      ; сдвигаем число в EAX на 4 разряда вправо = FFFFFFE0 >> 4 = 0FFFFFFE = 268435454
    ```
    Логический сдвиг вправо беззнакового числа на N разрядов вправо эквивалентен делению на 2^n. С числами со знаком такого не проходит. И в этом случае мы можем использовать арифметический сдвиг вправо:
    ```asm
    MOV EAX, -32    ; в EAX число -32 или FFFFFFE0h
    SAR EAX, 4      ; сдвигаем число в EAX на 4 разряда вправо = FFFFFFE0 >> 4 = FFFFFFFE = -2
    ```

    При арифметическим сдвиге вправо также устанавливаются флаги состояния. Последний отрасываемый бит копируется во флаг переноса CF. Если результат сдвига равен 0 (например, сдвигается положительное число), то также устанавливается флаг нуля ZF. Но в отличие от операции логического сдвига флаг переполнения OF всегда сброшен (так как знак числа не меняется), а флаг знака SF получает значение старшего бита числа.

- **ROL/ROR** — вращение влево/вправо.
    
    Операции вращения ведут себя так же, как операции сдвига, за тем исключением, что бит, смещенный с одного конца, помещается обратно в другой конец.
    ```asm
    MOV AL, 131    ; в AL число 131 или 10000011
    ROL AL, 2      ; вращаем число в AL на 2 разряда влево = 10000011 << 2 = 00001110 = 14
    ```
    **10**000011 << 2 = 000011**10**

    ```asm
    MOV AL, 131    ; в AL число 131 или 10000011
    ROR AL, 2      ; вращаем число в AL на 2 разряда вправо = 10000011 >> 2 = 11100000 = 224
    ```
    100000**11** >> 2 = **11**100000

    Эти инстркции также изменяются флаги состояния. Но в отличие от инструкций сдвига, инструкции поворота не влияют на установку флагов знака или нуля. Последний сдвинутый бит копируется во флаг переноса CF. При 1-битном повороте также изменяется флаг OF: при повороте влево флаг OF получает результат операции XOR (исключающее ИЛИ) двух первых старших битов, а при повороте вправо флаг OF получает результат операции XOR двух старших битов после поворота.

- **RCL/RCR** — вращение влево/вправо с переносом.
    
    При вращении влево смещаемый старший бит числа переходит во флаг переноса, а бит из флага переноса переходит в конец числа. При вращении вправо смещаемый младший бит переходит во флаг переноса, а бит из флага переноса переходит в начало числа.
    ```asm
    mov al, 131    ; в AL число 131 или 10000011
    rcl al, 2      ; вращаем число в AL на 2 разряда влево = 10000011 << 2 = 00001101 = 13
    ```
    При вращении происходят действия
    ```
    CF = 0          -> CF = 1         -> CF = 0
    AL = 10000011   -> AL = 00000110  -> AL = 00001101
    ```
    
---

### 3. **Арифметические команды**  
Операции сложения, вычитания, умножения, деления.  

- **ADD** — сложение:  
  ```asm
  ADD AX, BX        ; AX = AX + BX
  ADD AX, 5         ; AX = AX + 5
  ```  

- **SUB** — вычитание:  
  ```asm
  SUB AX, BX        ; AX = AX - BX
  SUB AX, 10        ; AX = AX - 10
  ```  

- **INC** — инкремент:  
  ```asm
  MOV EAX, 8
  INC EAX           ; EAX = EAX + 1
  ```  

- **DEC** — декремент:  
  ```asm
  MOV EAX, 8
  DEC EAX           ; EAX = EAX - 1
  ```  

- **MUL и IMUL** — умножение (`IMUL` умножает числа со знаком, а `MUL` - беззнаковые числа):  
    По умолчанию операция умножения производится с регистром аккумулятора `AL`/`AX`/`EAX`/`RAX`
    ```asm
    MOV AL, 5
    MOV BL, 10
    MUL BL          ; AX = AL * BL (результат в AX) 
    ```  
    Если инструкции передается два операнда, то она умножает первый операнд на второй и результат присваивает первому операнду, при этом первый операнд - всегда должен быть регистром, а операнды должны совпадать по размеру:
    ```asm
    MOV EAX, 3
    IMUL EAX, 5     ; EAX = EAX * 5 = 3 * 5 = 15
    ```
    Если при умножении происходит переполнение, то эта инструкция устанавливает флаги переноса CF и переполнения OF. В таком случае в AX/EAX/RAX помещается младшая часть результата, а в DX/EDX/RDX - старшая.
    ```
    MOV DX, 5
    MOV AX, 4
    MUL DX          ; DX:AX = AX * DX = 4 * 5 = 20
    ```

- **DIV и IDIV** — деление (`IDIV` делит два числа со знаком, а `DIV` - беззнаковые числа): 

    Инструкция `DIV` делит два беззнаковых числа. Если операнд 8-разрядный, то `DIV` делит регистр `AX` на операнд, помещая частное в `AL`, а остаток (по модулю) в `AH`.

    Если операнд 16-разрядный, то инструкция `DIV` делит 32-разрядное число в `DX:AX` на операнд, помещая частное в `AX`, а остаток в `DX`.

    Если операнд 32-разрядный, `DIV` делит 64-битное число в `EDX:EAX` на операнд, помещая частное в `EAX`, а остаток в `EDX`.

    И если операнд 64-разрядный, `DIV` делит 128-битное число в `RDX:RAX` на операнд, помещая частное в `RAX`, а остаток в `RDX`.

    Инструкция `IDIV` имеет аналогичное действие, только в качестве операндов принимает числа со знаком.

    Пример:
    ```asm
    MOV AX, 100       ; 16-разрядный регистр
    MOV BL, 10        ; 8-разрядное число
    DIV BL            ; AL = AX / BL (частное), AH = AX % BL (остаток)
    ```  
    Чуть более сложный случай - надо разделить 32-рарядное число на 16-разрядное:
    ```asm
    MOV EAX, 24003h   ; 32-разрядное число
    MOV EDX, EAX      ; копируем данные из EAX и EDX
    SHR EDX, 16       ; сдвигаем биты вправо, чтобы старшие 16 бит из EAX оказались в DX
    MOV BX, 10h       ; 16-разрядный регистр
    DIV BX            ; AX = 1200h (результат), DX = 3 (остаток)
    ```
    При этом в x86-64 нельзя просто разделить два числа одинаковой разрядности, например, одно 8-разрядное на другое 8-разрядное. Если знаменатель представляет собой 8-битное значение, числитель должен быть 16-битным значением. Если же нужно разделить одно 8-битное значение без знака на другое, то необходимо дополнить числитель нулями до 16 бит, загрузив числитель в регистр `AL`, а затем переместив 0 в регистр `AH`. Отсутствие расширения `AL` до нуля перед выполнением `DIV` может привести к тому, что x86-64 выдаст некорректный результат.

    Если нужно разделить два беззнаковых 16-разрядных числа, то надо расширить регистр `AX` (который содержит числитель) до регистра `DX`. Для этого достаточно загрузить 0 в регистр `DX`.

    Если нужно разделить одно беззнаковое 32-битное значение на другое, перед делением надо расширить регистр `EAX` нулями до `EDX` (загрузив 0 в `EDX`).

    И чтобы разделить одно 64-битное число на другое, перед делением нужно расширить `RAX` нулями до `RDX` (поместив 0 в `RDX`).

    Перед делением целочисленных значений со знаком одинаковой разрядности с помощью `IDIV` необходимо расширить знаком `AL` в AX (поместив знаковый бит числа в AH), `AX` в `DX` (знаковый бит в `DX`), `EAX` в `EDX` (знаковый бит в `EDX`) или `RAX` в `RDX` (знаковый бит в `RDX`). Для этого можно использовать следующие инструкции `CBW`, `CWD`, `CDQ` или `CQO`

    - `CBW`: преобразует байт в `AL` в слово в `AX` через расширение знаком

    - `CWD`: преобразует слово в `AX` в двойное слово в `DX:AX` через расширение знаком

    - `CDQ`: преобразует двойное слово в `EAX` в четверное слово в `EDX:EAX` с помощью расширения знаком

    - `CQO`: преобразует четверное слово в `RAX` в восьмеричное слово в `RDX:RAX` через расширение знаком

    - `CWDE`: преобразует слово в `AX` в двойное слово в `EAX` с помощью расширения знаком

    - `CQDE`: преобразует двойное слово в `EAX` в четверное слово в `RAX` с помощью расширения знаком
    ```asm
    MOV AX, -20
    MOV BX, 10   ; два 16-разрядных числа
    CWD          ; заполним DX знаковым битом из AX
    IDIV BX      ; AX =-2 (результат), DX = 0 (остаток)
    ```
---

### 3. **Команды перехода**

- **CMP** — сравнивает значения и устанавливает флаги, благодаря чему можно использовать условные переходы
  ```asm
  CMP AX, BX
  ```
  Операция сравнения фактически работает как вычитание и при сравнении устанавливаются флаги:

  - Флаг нуля ZF устанавливается, если AX = BX

  - Флаг знака SF устанавливается, если результат отрицательный. При этом установка флага НЕ означает, что AX обязательно меньше BX. Если AX = 7FFFh (32767) и BX = 0FFFFh (-1), то вычитание AX - BX дает отрицательное значение 8000h (поэтому будет установлен флаг знака). Другой пример: есть беззнаковые операнды AX = 0FFFFh и BX = 1. Здесь AX больше, чем BX, но их разница составляет 0FFFEh, что по-прежнему отрицательно. Поэтому для сравнения двух значений со знаком надо использовать вместе два флага - флаг знака и флаг переполнения:
    - Если ((SF = 0) и (OF = 1)) или ((SF = 1) и (OF = 0)), тогда AX меньше, чем BX
    - Если ((SF = 0) и (OF = 0)) или ((SF = 1) и (OF = 1)), тогда AX больше или равно BX
  Таким образом, если флаги SF и OF не равны, то AX меньше, чем BX. Если эти флаги равны, тогда AX больше или равно BX
  
  - Флаг переполнения OF устанавливается, если при вычитании произойдет переполнение знакового бита.
  
  - Флаг переноса CF устанавливается, если при вычитании AX - BX потребуется заимствование

- **JMP** — безусловный переход:  
  ```asm
  JMP LABEL         ; Переход на метку LABEL
  ```  

- **JE/JZ** — переход при равенстве/нуле. Проверяет флаг ZF == 1:  
  ```asm
  CMP AX, BX
  JE EQUAL          ; Переход на метку EQUAL, если AX == BX
  ```  

- **JNE/JNZ** — переход при неравенстве/ненуле. Проверяет флаг ZF == 0:  
  ```asm
  CMP AX, BX
  JNZ NOT_EQUAL     ; Переход на метку NOT_EQUAL, если AX != BX
  ```  

- **JA/JNBE** — переход, если превый операнд больше второго (беззнаковые). Проверяет, что оба флага CF == 0 и ZF == 0 

- **JAE/JNB/JNC** — переход, если первый операнд больше или равен второму (беззнаковые). Проверяет флаг CF == 0

- **JB/JNAE/JC** — переход, если первый операнд меньше второго (беззнаковые). Проверяет флаг CF == 1

- **JBE/JNA** — переход, если первый операнд меньше или равен второму (беззнаковые). Проверяет один из флагов CF == 1 или ZF == 1

- **JG/JNLE** — переход, если первый операнд больше второго (знаковые). Проверяет, что оба условия SF == OF и ZF == 0 выполняются

- **JGE/JNL** — переход, если первый операнд больше или равен второму (знаковые). Проверяет условие SF == OF

- **JL/JNGE** — переход, если первый операнд меньше второго (знаковые). Проверяет условие SF != OF

- **JLE/JNG** — переход, если первый операнд меньше или равен второму (знаковые). Проверяет одно из условий SF != OF или ZF == 1

### 3. **Логические команды**  
Побитовые операции: И, ИЛИ, исключающее ИЛИ, отрицание.  

- **AND** — побитовая операция И:  
  ```asm
  AND AX, 0F0Fh     ; AX = AX AND 0F0Fh
  ```  

- **OR** — побитовая операция ИЛИ:  
  ```asm
  OR AX, 00FFh      ; AX = AX OR 00FFh
  ```  

- **XOR** — побитовая операция исключающее ИЛИ:  
  ```asm
  XOR AX, AX        ; Обнулить AX (AX = AX XOR AX)
  ```  

- **NOT** — побитовая инверсия:  
  ```asm
  NOT AX            ; Инвертировать все биты AX
  ```  

---


### 4. **Установка битов по условию**  
Ряд инструкций позволяют установить однобайтовый операнд в 0 или 1 в зависимости от значений в регистре FLAGS. Основные из них:

- `setc`: устанавливает биты, если флаг переноса CF=1

- `setnc`: устанавливает биты, если флаг переноса CF=0

- `setz`: устанавливает биты, если флаг нуля ZF=1

- `setnz`: устанавливает биты, если флаг нуля ZF=0

- `sets`: устанавливает биты, если флаг знака SF=1

- `setns`: устанавливает биты, если флаг знака SF=0

- `seto`: устанавливает биты, если флаг переполнения OF=1

- `setno`: устанавливает биты, если флаг переполнения OF=0

Еще две дополнительные группы инструкций могут применяться после инструкции cmp. Они позволяют узнать, является ли один операнд меньше, равен или больше другого. Одна группа предназначена для беззнакового сравнения, а вторая группа - для сравнения результатов со знаком.

|Инструкция|Условие|Описание|
|----|----|----|
|seta|CF = 0, ZF = 0|Если первый операнд больше второго|
|setnbe|CF = 0, ZF = 0|Если первый операнд не меньше и не равен второму (по сути больше второго - аналог seta)|
|setae|CF = 0|Если первый операнд больше или равен второму|
|setnb|CF = 0|Если первый операнд не меньше второго (аналог setae)|
|setb|CF = 1|Если первый операнд меньше второго|
|setnae|CF = 1|Если первый операнд не больше и не равен второму (меньше второго - аналог setb)|
|setbe|CF = 1 или ZF = 1|Если первый операнд меньше или равен второму|
|setna|CF = 1 или ZF = 1|Если первый операнд не больше второго (аналогичен setbe)|
|sete|ZF = 1|Если операнды равны (аналогичен setz)|
|setne|ZF = 0|Если операнды не равны (аналогичен setzn)|

|Инструкция|Условие|Описание|
|----|----|----|
|setg|SF = OF и ZF = 0|Если первый операнд больше второго|
|setnle|SF = OF и ZF = 0|Если первый операнд не меньше и не равен второму (по сути больше второго - аналог setп)|
|setge|SF = OF|Если первый операнд больше или равен второму|
|setnl|SF = OF|Если первый операнд не меньше второго (аналог setge)|
|setl|Флаги SF и OF не равны|Если первый операнд меньше второго|
|setnge|Флаги SF и OF не равны|Если первый операнд не больше и не равен второму (меньше второго - аналог setl)|
|setle|Флаги SF и OF не равны или ZF = 1|Если первый операнд меньше или равен второму|
|setng|Флаги SF и OF не равны или ZF = 1|Если первый операнд не больше второго (аналогичен setle)|
|sete|ZF = 1|Если операнды равны (аналогичен setz)|
|setne|ZF = 0|Если операнды не равны (аналогичен setzn)|

### 4. **Команды управления потоком**  
Вызов подпрограмм, возврат из подпрограмм.  

- **CALL** — вызов подпрограммы:  
  ```asm
  CALL SUBROUTINE   ; Вызов подпрограммы по метке SUBROUTINE
  ```  

- **RET** — возврат из подпрограммы:  
  ```asm
  RET               ; Возврат к месту вызова
  ```  

---

### 5. **Команды работы с памятью**  
Чтение и запись данных в оперативную память.  

- **MOV** — перемещение данных:  
  ```asm
  MOV [BX], AX      ; Записать значение из AX в память по адресу в BX
  MOV AX, [SI]      ; Загрузить в AX значение из памяти по адресу из SI
  ```  

- **LEA** — загрузка адреса:  
  ```asm
  LEA EDX, VAR     ; Загрузить адрес переменной VAR в EDX
  MOV EAX, [EDX]   ; Загрузить в EAX значение из памяти по адресу из EDX
  ```  

  При адресации можно использовать смещение, указываемое в байтах
  ```asm
  n1 dword 1
  n2 dword 3

  lea rbx, n1         ; загружаем в регистр RBX адрес переменной n1
  mov eax, [rbx + 4]  ; в регистр EAX загружаем данные с адреса [rbx + 4], то есть переменной n2
  ```

  При помощи индексного регистра можно выполнять смешение с масштабироавнием, домножая значение индексного регистра на коэфициенты 1, 2, 4, 8
  ```asm
  numbers dword 11, 12, 13, 14, 15, 16, 17, 18

  lea rbx, numbers         ; загружаем в регистр RBX адрес переменной numbers
  mov rsi, 5               ; индекс получаемого двойного слова - получаем 6 элемент           
  mov eax, [rbx + rsi*4]   ; в регистр EAX загружаем данные с адреса [rbx + rsi*4], то есть число 16
  ```

### 6. **Цепочечные команды**  
Цепочечные команды в MASM предназначены для работы с последовательностями байтов или слов в памяти. Они выполняют однотипные операции, используя регистры SI/ESI (источник) и DI/EDI (приемник). Для многократного выполнения этих операций применяется REP (повторение).

Цепочечные команды удобны для обработки массивов и строк, так как позволяют избежать явного использования циклов.

| Команда  | Назначение |
|----------|-----------|
| `MOVS`  | Копирование данных |
| `LODS`  | Загрузка данных в `EAX` |
| `STOS`  | Запись данных из `EAX` |
| `CMPS`  | Сравнение строк |
| `SCAS`  | Поиск в строке |

#### **Флаги и регистры, влияющие на работу:**
- **`DF (Direction Flag)`**:  
  - `DF = 0` (используется `CLD`) — движение вперед (инкремент `ESI`/`EDI`).
  - `DF = 1` (используется `STD`) — движение назад (декремент `ESI`/`EDI`).
- **`ECX`**:  
  - Используется для количества повторений (`REP`, `REPE`, `REPNE`).

---
### **Копирование данных с помощью `MOVS`**
Команда `MOVS` копирует данные из `ESI` в `EDI`. Она бывает в трех вариантах:
- `MOVSB` — копирует байт (`BYTE`).
- `MOVSW` — копирует слово (`WORD`).
- `MOVSD` — копирует двойное слово (`DWORD`).

```cpp
char src[] = "Hello, ASM!";
char dst[20];
int x = sizeof(src);

_asm {
    cld           ;сброс флага направления
    lea esi, src  ;загрузка адреса источника в esi
    lea edi, dst  ;загрузка адреса приемника в edi
    mov ecx, x    ;загрузка счетчика
    rep movsb
}

printf("Copied: %s\n", dst);
```

Здесь `rep movsb` копирует строку посимвольно из `src` в `dst`.

---
### **Загрузка данных с `LODS`**
`LODS` загружает байт (`LODSB`), слово (`LODSW`) или двойное слово (`LODSD`) из `ESI` в `EAX`.

#### **Пример: Вывод строки посимвольно**
```cpp
char str[] = "ASM";
char x;

__asm {
    cld
    lea esi, str   
    lodsb          
    mov x, al
}

printf("First char: %c\n", x);
```
Здесь `lodsb` загружает первый символ строки в `AL`.

---

### **Запись данных с `STOS`**
`STOS` записывает байт (`STOSB`), слово (`STOSW`) или двойное слово (`STOSD`) из `EAX` в `EDI`.

#### **Пример: Заполнение массива символами**
```cpp
char buffer[10];

__asm {
    cld
    lea edi, buffer       ;Указатель на массив
    mov al, 'A'           ;Значение, которое будем записывать
    mov ecx, 9            ;Количество записей
    rep stosb             ;Заполняем массив 'A'
    mov byte ptr[edi], 0  ;Завершаем строку нулём
}

printf("Buffer: %s\n", buffer);
```
Здесь `rep stosb` заполняет `buffer` символами `'A'`.

---

### **Сравнение строк с `CMPS`**
`CMPS` сравнивает байты (`CMPSB`), слова (`CMPSW`) или двойные слова (`CMPSD`).

#### **Пример: сравнение двух строк**
```cpp
char str1[] = "Hello";
char str2[] = "Hellp";
int result;
int x = strlen(str1);

__asm {
    cld
    lea esi, str1
    lea edi, str2
    mov ecx, x
    repe cmpsb
    setz al
    mov result, eax
}

printf("Strings are %s\n", result ? "equal" : "different");
```
Здесь `repe cmpsb` сравнивает символы, пока они равны.

---

### **7. Поиск символа с `SCAS`**
`SCAS` ищет байт (`SCASB`), слово (`SCASW`) или двойное слово (`SCASD`).

#### **Пример: поиск символа в строке**
```cpp
char text[] = "Hello, world!";
char target = 'o';
int pos = -1;
int x = sizeof(text);
__asm {
    cld
    lea edi, text       ; загружаем адрес переменной text
    mov esi, edi        ; копируем адрес в ESI для последующего поиска индекса
    mov al, target      ; в AL символ для поиска
    mov ecx, x          ; в ECX количество символов строки
    repne scasb         ; ищем байт
    jnz not_found
    sub edi, esi        ; если символ найден, получаем индекс следующего символа после найденного
    dec edi             ; отнимает 1 байт - получем индекс найденного символа
    mov pos, edi
    not_found:
}

printf("Character found at index: %d\n", pos);
```
Здесь `repne scasb` ищет `target` в `text`.

---
