# Команды языка ассемблера

Команды языка ассемблера прямо соответствуют отдельным командам процессора или их последовательностям и представляют собой более удобную для человека символьную форму записи команд и их аргументов

```asm
[метка]: [[префикс] мнемокод [операнд1 {, операнд2}]][;комментарий]
```

Мнемокод - инструкция процессору. К ней могут быть добавлены префиксы (повторения, изменения типа адресации и пр.) 

Операнды - объекты, на которые воздействует команда (константы, регистры, адреса в памяти и т.д.)

Команды языка ассемблера можно разделить на несколько категорий:  

---

### 1. **Команды перемещения данных**  
Перемещение данных между регистрами, памятью и непосредственными значениями.  

- **MOV** — перемещение данных:  
  ```asm
  MOV AX, BX        ; Скопировать значение из BX в AX
  MOV AX, 1234h     ; Загрузить в AX число 1234h
  MOV [SI], AX      ; Записать значение из AX по адресу, хранящемуся в SI
  MOV AL, [1234h]   ; Считать байт по адресу 1234h в AL
  ```  
  Оба операнда должны быть одинакового размера.

  Если необходимо поместить в регистр большего размера значение меньшего размера можно использовать команды перемещения с расширением: `MOVSX` для знакового расширения и `MOVZX` для беззнакового  
  ```
  MOVSXD dest, source     ; если dest - 64-разрядный операнд и source - 32-разрядный
  MOVSX dest, source      ; для всех остальных комбинаций операндов
  MOVZXD dest, source     ; если dest - 64-разрядный операнд и source - 32-разрядный
  MOVZX dest, source      ; для всех остальных комбинаций операндов
  ```
  Пример:
  ```asm
  MOV DL, -5
  MOVSX EAX, DL     ; EAX = -5
  ```

- **PUSH** — запись данных в стек:  
  ```asm
  PUSH AX           ; Сохранить значение AX в стеке
  ```  

- **POP** — извлечение данных из стека:  
  ```asm
  POP BX            ; Извлечь верхнее значение из стека в BX
  ```  

- **XCHG** — обмен значениями:  
  ```asm
  XCHG AX, BX       ; Поменять местами значения AX и BX
  ```  
---
### 2. **Команды сдвига и вращения**
Инструкции сдвига и вращения манипулируют отдельными битами числа.

- **SHL** — сдвиг влево 
    ```asm
    MOV AL, 5       ; в AL число 5 или 00000101
    SHL AL, 1       ; сдвигаем число в AL на 1 разряд влево = 00000101 << 1 = 00001010 = 10
    ```
    Фактически сдвиг влево на n разрядов эквивалентен умножению на 2^n
    ```asm
    MOV AL, 69      ; в AL число 69 или 01000101
    MOV CL, 2       ; в CL число 2
    SHL AL, CL      ; сдвигаем число в AL на 2 разряда влево = 01000101 << 2 = 00010100 = 20
    ```
    Стоит учитывать, что при сдвиге влево последний отбрасываемый бит копируется в регистр флагов во флаг переноса CF. Кроме флага CF инструкция сдвига также устанавливает и другие флаги состояния. Флаг нуля ZF устанавливается, если в результате сдвига получилось число 0. Флаг знака устанавливается, если старший бит результата равен 1. Флаг переполнения OF устанавливается, если при сдвиге на 1 разряд меняется старший бит (с 0 на 1 или с 1 на 0).

- **SHR** — логический сдвиг вправо 
    ```asm
    MOV AL, 69     ; в AL число 69 или 01000101
    SHR AL, 2      ; сдвигаем число в AL на 2 разряда вправо = 01000101 >> 2 = 00010001 = 17
    ```
    Фактически сдвиг вправо на n разрядов для беззнаковых чисел эквивалентен делению на 2^n

    При сдвиге вправо также устанавливаются флаги состояния. Последний отрасываемый бит копируется во флаг переноса CF. Если результат сдвига равен 0, то также устанавливается флаг нуля ZF. Если при сдвиге вправо на 1 разряд меняется старший бит (с 1 на 0), то также устанавливается флаг переполнения OF. При этом флаг знака SF всегда сбрасывается, так как слева в любом случае добавляется 0.

- **SAR** — арифметический сдвиг вправо. 
    
    По большей части работает аналогично логическому, за исключением того, что сдвигаемое число дополняется не 0, а значением старшего бита. Это может быть необходимо для работы с отрицательными числами.
    ```asm
    MOV EAX, -32    ; в EAX число -32 или FFFFFFE0h
    SHR EAX, 4      ; сдвигаем число в EAX на 4 разряда вправо = FFFFFFE0 >> 4 = 0FFFFFFE = 268435454
    ```
    Логический сдвиг вправо беззнакового числа на N разрядов вправо эквивалентен делению на 2^n. С числами со знаком такого не проходит. И в этом случае мы можем использовать арифметический сдвиг вправо:
    ```asm
    MOV EAX, -32    ; в EAX число -32 или FFFFFFE0h
    SAR EAX, 4      ; сдвигаем число в EAX на 4 разряда вправо = FFFFFFE0 >> 4 = FFFFFFFE = -2
    ```

    При арифметическим сдвиге вправо также устанавливаются флаги состояния. Последний отрасываемый бит копируется во флаг переноса CF. Если результат сдвига равен 0 (например, сдвигается положительное число), то также устанавливается флаг нуля ZF. Но в отличие от операции логического сдвига флаг переполнения OF всегда сброшен (так как знак числа не меняется), а флаг знака SF получает значение старшего бита числа.

- **ROL/ROR** — вращение влево/вправо.
    
    Операции вращения ведут себя так же, как операции сдвига, за тем исключением, что бит, смещенный с одного конца, помещается обратно в другой конец.
    ```asm
    MOV AL, 131    ; в AL число 131 или 10000011
    ROL AL, 2      ; вращаем число в AL на 2 разряда влево = 10000011 << 2 = 00001110 = 14
    ```
    **10**000011 << 2 = 000011**10**

    ```asm
    MOV AL, 131    ; в AL число 131 или 10000011
    ROR AL, 2      ; вращаем число в AL на 2 разряда вправо = 10000011 >> 2 = 11100000 = 224
    ```
    100000**11** >> 2 = **11**100000

    Эти инстркции также изменяются флаги состояния. Но в отличие от инструкций сдвига, инструкции поворота не влияют на установку флагов знака или нуля. Последний сдвинутый бит копируется во флаг переноса CF. При 1-битном повороте также изменяется флаг OF: при повороте влево флаг OF получает результат операции XOR (исключающее ИЛИ) двух первых старших битов, а при повороте вправо флаг OF получает результат операции XOR двух старших битов после поворота.

- **RCL/RCR** — вращение влево/вправо с переносом.
    
    При вращении влево смещаемый старший бит числа переходит во флаг переноса, а бит из флага переноса переходит в конец числа. При вращении вправо смещаемый младший бит переходит во флаг переноса, а бит из флага переноса переходит в начало числа.
    ```asm
    mov al, 131    ; в AL число 131 или 10000011
    rcl al, 2      ; вращаем число в AL на 2 разряда влево = 10000011 << 2 = 00001101 = 13
    ```
    При вращении происходят действия
    ```
    CF = 0          -> CF = 1         -> CF = 0
    AL = 10000011   -> AL = 00000110  -> AL = 00001101
    ```
    
---

### 3. **Арифметические команды**  
Операции сложения, вычитания, умножения, деления.  

- **ADD** — сложение:  
  ```asm
  ADD AX, BX        ; AX = AX + BX
  ADD AX, 5         ; AX = AX + 5
  ```  

- **SUB** — вычитание:  
  ```asm
  SUB AX, BX        ; AX = AX - BX
  SUB AX, 10        ; AX = AX - 10
  ```  

- **INC** — инкремент:  
  ```asm
  MOV EAX, 8
  INC EAX           ; EAX = EAX + 1
  ```  

- **DEC** — декремент:  
  ```asm
  MOV EAX, 8
  DEC EAX           ; EAX = EAX - 1
  ```  

- **MUL и IMUL** — умножение (`IMUL` умножает числа со знаком, а `MUL` - беззнаковые числа):  
    По умолчанию операция умножения производится с регистром аккумулятора `AL`/`AX`/`EAX`/`RAX`
    ```asm
    MOV AL, 5
    MOV BL, 10
    MUL BL          ; AX = AL * BL (результат в AX) 
    ```  
    Если инструкции передается два операнда, то она умножает первый операнд на второй и результат присваивает первому операнду, при этом первый операнд - всегда должен быть регистром, а операнды должны совпадать по размеру:
    ```asm
    MOV EAX, 3
    IMUL EAX, 5     ; EAX = EAX * 5 = 3 * 5 = 15
    ```
    Если при умножении происходит переполнение, то эта инструкция устанавливает флаги переноса CF и переполнения OF. В таком случае в AX/EAX/RAX помещается младшая часть результата, а в DX/EDX/RDX - старшая.
    ```
    MOV DX, 5
    MOV AX, 4
    MUL DX          ; DX:AX = AX * DX = 4 * 5 = 20
    ```

- **DIV и IDIV** — деление (`IDIV` делит два числа со знаком, а `DIV` - беззнаковые числа): 

    Инструкция `DIV` делит два беззнаковых числа. Если операнд 8-разрядный, то `DIV` делит регистр `AX` на операнд, помещая частное в `AL`, а остаток (по модулю) в `AH`.

    Если операнд 16-разрядный, то инструкция `DIV` делит 32-разрядное число в `DX:AX` на операнд, помещая частное в `AX`, а остаток в `DX`.

    Если операнд 32-разрядный, `DIV` делит 64-битное число в `EDX:EAX` на операнд, помещая частное в `EAX`, а остаток в `EDX`.

    И если операнд 64-разрядный, `DIV` делит 128-битное число в `RDX:RAX` на операнд, помещая частное в `RAX`, а остаток в `RDX`.

    Инструкция `IDIV` имеет аналогичное действие, только в качестве операндов принимает числа со знаком.

    Пример:
    ```asm
    MOV AX, 100       ; 16-разрядный регистр
    MOV BL, 10        ; 8-разрядное число
    DIV BL            ; AL = AX / BL (частное), AH = AX % BL (остаток)
    ```  
    Чуть более сложный случай - надо разделить 32-рарядное число на 16-разрядное:
    ```asm
    MOV EAX, 24003h   ; 32-разрядное число
    MOV EDX, EAX      ; копируем данные из EAX и EDX
    SHR EDX, 16       ; сдвигаем биты вправо, чтобы старшие 16 бит из EAX оказались в DX
    MOV BX, 10h       ; 16-разрядный регистр
    DIV BX            ; AX = 1200h (результат), DX = 3 (остаток)
    ```
    При этом в x86-64 нельзя просто разделить два числа одинаковой разрядности, например, одно 8-разрядное на другое 8-разрядное. Если знаменатель представляет собой 8-битное значение, числитель должен быть 16-битным значением. Если же нужно разделить одно 8-битное значение без знака на другое, то необходимо дополнить числитель нулями до 16 бит, загрузив числитель в регистр `AL`, а затем переместив 0 в регистр `AH`. Отсутствие расширения `AL` до нуля перед выполнением `DIV` может привести к тому, что x86-64 выдаст некорректный результат.

    Если нужно разделить два беззнаковых 16-разрядных числа, то надо расширить регистр `AX` (который содержит числитель) до регистра `DX`. Для этого достаточно загрузить 0 в регистр `DX`.

    Если нужно разделить одно беззнаковое 32-битное значение на другое, перед делением надо расширить регистр `EAX` нулями до `EDX` (загрузив 0 в `EDX`).

    И чтобы разделить одно 64-битное число на другое, перед делением нужно расширить `RAX` нулями до `RDX` (поместив 0 в `RDX`).

    Перед делением целочисленных значений со знаком одинаковой разрядности с помощью `IDIV` необходимо расширить знаком `AL` в AX (поместив знаковый бит числа в AH), `AX` в `DX` (знаковый бит в `DX`), `EAX` в `EDX` (знаковый бит в `EDX`) или `RAX` в `RDX` (знаковый бит в `RDX`). Для этого можно использовать следующие инструкции `CBW`, `CWD`, `CDQ` или `CQO`

    - `CBW`: преобразует байт в `AL` в слово в `AX` через расширение знаком

    - `CWD`: преобразует слово в `AX` в двойное слово в `DX:AX` через расширение знаком

    - `CDQ`: преобразует двойное слово в `EAX` в четверное слово в `EDX:EAX` с помощью расширения знаком

    - `CQO`: преобразует четверное слово в `RAX` в восьмеричное слово в `RDX:RAX` через расширение знаком

    - `CWDE`: преобразует слово в `AX` в двойное слово в `EAX` с помощью расширения знаком

    - `CQDE`: преобразует двойное слово в `EAX` в четверное слово в `RAX` с помощью расширения знаком
    ```asm
    MOV AX, -20
    MOV BX, 10   ; два 16-разрядных числа
    CWD          ; заполним DX знаковым битом из AX
    IDIV BX      ; AX =-2 (результат), DX = 0 (остаток)
    ```
---

### 3. **Команды перехода**

- **CMP** — сравнивает значения и устанавливает флаги, благодаря чему можно использовать условные переходы
  ```asm
  CMP AX, BX
  ```
  Операция сравнения фактически работает как вычитание и при сравнении устанавливаются флаги:

  - Флаг нуля ZF устанавливается, если AX = BX

  - Флаг знака SF устанавливается, если результат отрицательный. При этом установка флага НЕ означает, что AX обязательно меньше BX. Если AX = 7FFFh (32767) и BX = 0FFFFh (-1), то вычитание AX - BX дает отрицательное значение 8000h (поэтому будет установлен флаг знака). Другой пример: есть беззнаковые операнды AX = 0FFFFh и BX = 1. Здесь AX больше, чем BX, но их разница составляет 0FFFEh, что по-прежнему отрицательно. Поэтому для сравнения двух значений со знаком надо использовать вместе два флага - флаг знака и флаг переполнения:
    - Если ((SF = 0) и (OF = 1)) или ((SF = 1) и (OF = 0)), тогда AX меньше, чем BX
    - Если ((SF = 0) и (OF = 0)) или ((SF = 1) и (OF = 1)), тогда AX больше или равно BX
  Таким образом, если флаги SF и OF не равны, то AX меньше, чем BX. Если эти флаги равны, тогда AX больше или равно BX
  
  - Флаг переполнения OF устанавливается, если при вычитании произойдет переполнение знакового бита.
  
  - Флаг переноса CF устанавливается, если при вычитании AX - BX потребуется заимствование

- **JMP** — безусловный переход:  
  ```asm
  JMP LABEL         ; Переход на метку LABEL
  ```  

- **JE/JZ** — переход при равенстве/нуле. Проверяет флаг ZF == 1:  
  ```asm
  CMP AX, BX
  JE EQUAL          ; Переход на метку EQUAL, если AX == BX
  ```  

- **JNE/JNZ** — переход при неравенстве/ненуле. Проверяет флаг ZF == 0:  
  ```asm
  CMP AX, BX
  JNZ NOT_EQUAL     ; Переход на метку NOT_EQUAL, если AX != BX
  ```  

- **JA/JNBE** — переход, если превый операнд больше второго (беззнаковые). Проверяет, что оба флага CF == 0 и ZF == 0 

- **JAE/JNB/JNC** — переход, если первый операнд больше или равен второму (беззнаковые). Проверяет флаг CF == 0

- **JB/JNAE/JC** — переход, если первый операнд меньше второго (беззнаковые). Проверяет флаг CF == 1

- **JBE/JNA** — переход, если первый операнд меньше или равен второму (беззнаковые). Проверяет один из флагов CF == 1 или ZF == 1

- **JG/JNLE** — переход, если первый операнд больше второго (знаковые). Проверяет, что оба условия SF == OF и ZF == 0 выполняются

- **JGE/JNL** — переход, если первый операнд больше или равен второму (знаковые). Проверяет условие SF == OF

- **JL/JNGE** — переход, если первый операнд меньше второго (знаковые). Проверяет условие SF != OF

- **JLE/JNG** — переход, если первый операнд меньше или равен второму (знаковые). Проверяет одно из условий SF != OF или ZF == 1

### 3. **Логические команды**  
Побитовые операции: И, ИЛИ, исключающее ИЛИ, отрицание.  

- **AND** — побитовая операция И:  
  ```asm
  AND AX, 0F0Fh     ; AX = AX AND 0F0Fh
  ```  

- **OR** — побитовая операция ИЛИ:  
  ```asm
  OR AX, 00FFh      ; AX = AX OR 00FFh
  ```  

- **XOR** — побитовая операция исключающее ИЛИ:  
  ```asm
  XOR AX, AX        ; Обнулить AX (AX = AX XOR AX)
  ```  

- **NOT** — побитовая инверсия:  
  ```asm
  NOT AX            ; Инвертировать все биты AX
  ```  

---

### 4. **Команды управления потоком**  
Переходы, вызов подпрограмм, возврат из подпрограмм.  

- **JMP** — безусловный переход:  
  ```asm
  JMP LABEL         ; Переход на метку LABEL
  ```  

- **JE/JZ** — переход при равенстве/нуле:  
  ```asm
  CMP AX, BX
  JE EQUAL          ; Переход на метку EQUAL, если AX == BX
  ```  

- **JNE/JNZ** — переход при неравенстве/ненуле:  
  ```asm
  CMP AX, BX
  JNE NOT_EQUAL     ; Переход на метку NOT_EQUAL, если AX != BX
  ```  

- **CALL** — вызов подпрограммы:  
  ```asm
  CALL SUBROUTINE   ; Вызов подпрограммы по метке SUBROUTINE
  ```  

- **RET** — возврат из подпрограммы:  
  ```asm
  RET               ; Возврат к месту вызова
  ```  

---

### 5. **Команды работы с памятью**  
Чтение и запись данных в оперативную память.  

- **MOV** — перемещение данных:  
  ```asm
  MOV [BX], AX      ; Записать значение из AX в память по адресу BX
  MOV AX, [SI]      ; Загрузить в AX значение из памяти по адресу SI
  ```  

- **LEA** — загрузка адреса:  
  ```asm
  LEA DX, [VAR]     ; Загрузить адрес переменной VAR в DX
  ```  

- **STOS** — запись данных в память:  
  ```asm
  STOSB             ; Записать байт из AL в память, адресуемую ES:DI
  ```  

---

### 6. **Команды работы с флагами**  
Флаги — это специальные биты в регистре флагов процессора, отражающие состояние последней выполненной операции.  

- **CLC** — сброс флага переноса:  
  ```asm
  CLC               ; CF = 0
  ```  

- **STC** — установка флага переноса:  
  ```asm
  STC               ; CF = 1
  ```  

- **CMC** — инверсия флага переноса:  
  ```asm
  CMC               ; CF = NOT CF
  ```  

- **SAHF/LAHF** — сохранение/загрузка флагов в регистр AH:  
  ```asm
  SAHF              ; Сохранить флаги в AH
  LAHF              ; Загрузить флаги из AH
  ```  

---

### 7. **Команды работы с устройствами ввода-вывода**  
Используются для взаимодействия с периферийными устройствами.  

- **IN** — чтение данных из порта:  
  ```asm
  IN AL, DX         ; Прочитать байт из порта DX в AL
  ```  

- **OUT** — запись данных в порт:  
  ```asm
  OUT DX, AL        ; Записать байт из AL в порт DX
  ```  

---

### 8. **Пример программы с использованием различных команд**  

Программа складывает два числа и сохраняет результат в памяти:  
```asm
section .data
    num1 db 5        ; Первое число
    num2 db 10       ; Второе число
    result db 0      ; Результат

section .text
    mov al, [num1]   ; Загрузить первое число в AL
    add al, [num2]   ; Сложить с вторым числом
    mov [result], al ; Сохранить результат
    hlt              ; Завершение программы
```  

Этот раздел можно дополнить демонстрацией работы кода в эмуляторе или среде разработки ассемблера, чтобы наглядно объяснить поведение каждой команды.